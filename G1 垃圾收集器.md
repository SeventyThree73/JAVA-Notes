**G1 垃圾收集器（Garbage First Garbage Collector）** 是一种用于 Java 虚拟机（JVM）的高性能垃圾回收器，专门为具有大内存和多核 CPU 的服务器应用程序设计。G1 GC 是为了解决 **CMS（Concurrent Mark-Sweep）垃圾收集器**的局限性而引入的，具有低延迟和高吞吐量的特点，并且可以更好地控制垃圾回收时的停顿时间。

![](/src/G1垃圾收集器.png)

### 1. **G1 GC 的基本概念**

#### 1.1 **分区（Region）概念**
与传统的垃圾回收器将堆划分为**年轻代（Young Generation）**和**老年代（Old Generation）**不同，G1 GC 将整个堆划分为多个大小相同的**分区（Region）**。每个分区可以分别作为年轻代或老年代的一部分，或者用来存储大对象。

- 每个分区的大小由 `-XX:G1HeapRegionSize` 参数决定，通常是 1MB 到 32MB 之间。
- G1 GC 的目标是通过收集垃圾最多的区域来最大化内存回收效率，因此称为 **"Garbage First"**。

#### 1.2 **分代的概念仍然存在**
虽然 G1 GC 引入了分区的概念，但仍然保留了传统的**分代收集**思想。即：
- **年轻代**：存放新创建的对象，大多数对象很快被回收。
- **老年代**：存放生命周期较长的对象。

此外，G1 GC 还有一个专门的分区用于存放**大对象**（Humongous Objects），这些对象占用内存块超过单个分区的一半。

### 2. **G1 GC 的工作流程**

G1 GC 的工作流程分为以下几个主要阶段，主要包括**年轻代收集**和**混合收集**（即同时收集年轻代和老年代）：

#### 2.1 **年轻代垃圾回收（Young GC）**

年轻代垃圾回收主要发生在年轻代的分区（Eden 和 Survivor 区域），采用**复制算法**来进行垃圾回收。当 Eden 区填满时，触发一次 Young GC，将存活的对象从 Eden 区复制到 Survivor 区或老年代。

- **Eden 区到 Survivor 区的移动**：存活的对象被移动到 Survivor 区。
- **Survivor 区到老年代的晋升**：经历多次 Young GC 且依然存活的对象会被晋升到老年代。

**特点**：
- 仅收集年轻代分区。
- 年轻代回收时间短，暂停时间短。

#### 2.2 **混合回收（Mixed GC）**

混合回收是 G1 GC 的核心功能，G1 GC 会在老年代内存使用率达到一定阈值时（由 `-XX:InitiatingHeapOccupancyPercent` 控制，默认是 45%），触发 Mixed GC。它不仅回收年轻代，还会同时回收一部分老年代分区。

**特点**：
- 并不一次性回收整个老年代，而是按需选择部分老年代分区进行回收，减少全堆回收带来的长时间停顿。
- 混合回收中包含对年轻代和老年代的分区进行回收。

#### 2.3 **并发标记阶段**

在混合回收之前，G1 GC 会执行一个**并发标记周期**，用于识别老年代中可以回收的分区。这个过程主要包括以下步骤：

1. **初始标记阶段（Initial Marking）**：标记 GC Roots 直接引用的对象。这个阶段需要暂停应用程序，时间非常短，会和一次 Young GC 一起进行。
   
2. **并发标记阶段（Concurrent Marking）**：从 GC Roots 开始并发地遍历堆，标记所有存活的对象。这个阶段与应用程序并发执行，因此不会中断应用程序的运行。

3. **最终标记阶段（Final Marking）**：处理在并发标记阶段中产生的对象引用变动，修正标记结果。此阶段会短暂暂停应用程序。

4. **清理阶段（Cleanup）**：计算哪些分区可以回收，标记空闲分区并将其回收。部分操作需要暂停应用程序。

**特点**：
- 并发标记过程与应用程序同时进行，减少了停顿时间。
- 标记周期完成后，G1 GC 将确定哪些老年代分区有大量垃圾，并在 Mixed GC 中进行回收。

### 3. **G1 GC 的优势**

#### 3.1 **可预测的停顿时间**
G1 GC 的设计目标之一是提供可预测的垃圾回收停顿时间。用户可以通过 `-XX:MaxGCPauseMillis` 参数指定期望的最大停顿时间，G1 GC 会根据用户的目标调整垃圾回收的行为，尽量在满足该时间限制的情况下进行内存回收。

#### 3.2 **区域化管理与并发回收**
- **区域化管理**：G1 GC 通过将堆划分为多个小区域（Region），允许更加精细化的内存管理，避免了传统的老年代回收中需要一次性遍历整个堆的情况。
- **并发回收**：G1 GC 在进行标记和回收时，大部分工作可以与应用程序并发执行，从而减少对应用程序的停顿时间。

#### 3.3 **避免了内存碎片**
G1 GC 在回收老年代时，会自动进行**压缩**操作，避免了 CMS 收集器产生的**内存碎片问题**。压缩操作将存活对象集中到堆的一部分，腾出连续的内存空间，方便大对象分配。

### 4. **G1 GC 的不足**

虽然 G1 GC 在大多数场景下表现良好，但它也有一些缺点：

#### 4.1 **额外的开销**
- **并发开销**：由于 G1 GC 在标记和清除阶段与应用程序并发执行，可能会带来一定的 CPU 开销。在某些情况下，并发执行的回收线程可能与应用程序竞争 CPU 资源，导致性能下降。
- **复杂性**：G1 GC 的内部机制比其他收集器（如 Parallel GC 或 Serial GC）更加复杂，因此在某些场景下的调优和诊断也更加困难。

#### 4.2 **适用场景的限制**
G1 GC 最适合大内存、多核服务器的应用程序，对于小内存应用来说，可能无法充分发挥其优势。同时，G1 GC 在非常短的停顿时间目标下，可能难以达到理想的回收效果。

### 5. **G1 GC 的调优参数**

G1 GC 提供了许多可调参数来控制其行为，常用的调优参数包括：

- **`-XX:+UseG1GC`**：启用 G1 垃圾收集器。
  
- **`-XX:MaxGCPauseMillis=<N>`**：设置期望的最大垃圾回收停顿时间。G1 GC 会尝试满足这个目标（单位是毫秒），但不能保证严格遵守。

- **`-XX:InitiatingHeapOccupancyPercent=<N>`**：设置在老年代达到多高的内存占用比例时触发并发标记周期（默认是 45%）。较低的值会导致更频繁的垃圾回收。

- **`-XX:G1HeapRegionSize=<N>`**：设置 G1 中每个分区的大小。默认情况下，JVM 会根据堆大小动态调整此参数，一般在 1MB 到 32MB 之间。

- **`-XX:ParallelGCThreads=<N>`**：设置 G1 GC 使用的并行线程数量。一般设置为与 CPU 核心数量相同。

- **`-XX:ConcGCThreads=<N>`**：设置并发标记阶段的线程数量。通常设置为 CPU 核心数量的四分之一。

### 6. **G1 GC 与其他垃圾收集器的对比**

#### 6.1 **与 CMS GC 的对比**
- **碎片问题**：G1 GC 在进行回收时，会自动整理内存，避免了 CMS 收集器容易产生的内存碎片问题。
- **可预测的停顿时间**：G1 GC 可以通过设置 `MaxGCPauseMillis` 来控制停顿时间，CMS 收集器则难以做到这一点，特别是在老年代回收时。

#### 6.2 **与 Parallel GC 的对比**
- **延迟控制**：Parallel GC 侧重于高吞吐量，适合在停顿时间要求不严格的场景中使用，而 G1 GC 则专注于减少停顿时间，适合对响应时间敏感的应用。
- **内存管理**：G1 GC 通过分

区和并发回收，使得大内存场景下的垃圾回收更加灵活，而 Parallel GC 则更适合中小型堆的应用。

### 7. **适用场景**

G1 GC 适用于以下场景：
- **大堆内存**：G1 GC 特别适合用于内存较大的系统，如 4GB 以上的堆空间。
- **多核 CPU**：由于 G1 GC 是并行和并发回收的，具有较多 CPU 核心的服务器能够更好地发挥其优势。
- **低延迟要求的应用**：如响应时间敏感的在线服务和后台服务，特别是需要限制垃圾回收停顿时间的应用。

### 总结

**G1 GC** 是一种**低延迟、可预测**的垃圾收集器，适合大内存、多核 CPU 环境下的 Java 应用程序。它通过将堆划分为多个小区域，采用并行和并发的方式进行垃圾回收，并能够自动整理内存，避免了内存碎片问题。通过 `MaxGCPauseMillis` 参数，用户可以控制垃圾回收的最大停顿时间，帮助应用程序实现更好的响应性能。

尽管 G1 GC 相比于 CMS 提供了更好的内存管理和延迟控制，但它也引入了一定的复杂性。在特定场景下，G1 GC 的性能表现可能需要根据实际需求进行调优。