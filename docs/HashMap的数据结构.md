`HashMap` 是 Java 中最常用的数据结构之一，它是一种基于**哈希表**（Hash Table）实现的键值对（Key-Value）存储结构。`HashMap` 允许 `null` 键和 `null` 值，并且具有非常高效的查找、插入和删除操作。它的基本设计是为了在平均情况下提供 **O(1)** 的时间复杂度来进行插入、删除和查找操作。

### 1. **HashMap 的数据结构**

`HashMap` 的核心数据结构是一个**数组 + 链表 + 红黑树**的混合结构。它的底层是一个数组，数组中的每个元素称为**桶（bucket）**。每个桶中存储的是键值对（即 `Entry<K, V>` 或 `Node<K, V>`），当发生**哈希冲突**时（不同的键产生了相同的哈希值），使用**链表**或**红黑树**来解决冲突。

#### 1.1 **数组**
- `HashMap` 的底层是一个数组，数组中的每个位置存储的是一个 `Node<K, V>` 对象，`Node` 包含了键值对的信息。
- 数组中的每个元素可以看作一个桶，每个桶存储了对应哈希值的元素。
  
```java
transient Node<K,V>[] table;  // HashMap 底层数组
```

#### 1.2 **链表**
- 当多个键的哈希值相同时，它们会被存储在同一个桶中，形成一个链表结构。链表中的每个节点都是一个 `Node` 对象。
- **链表结构**：如果一个桶中出现多个元素，它们会以链表的形式链接在一起，新的元素会被添加到链表的头部。

#### 1.3 **红黑树**
- 当链表中的元素个数超过一定阈值（默认是 8）时，链表会转换为**红黑树**结构，以提高查找效率。
- **红黑树**是一个自平衡的二叉搜索树，保证了在最坏情况下查找、插入、删除操作的时间复杂度为 **O(log n)**，相比链表的 **O(n)** 提高了效率。

#### `Node` 的结构：
```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;       // 哈希值，用于定位在数组中的位置
    final K key;          // 键
    V value;              // 值
    Node<K,V> next;       // 指向下一个节点的指针，用于形成链表
}
```

### 2. **HashMap 的工作原理**

#### 2.1 **存储（put）操作**

当调用 `HashMap` 的 `put(K key, V value)` 方法时，`HashMap` 会按以下步骤进行操作：

1. **计算哈希值**：首先，`HashMap` 通过键的 `hashCode()` 方法计算出键的哈希值，并通过一个**扰动函数**对哈希值进一步处理，尽量让哈希值分布均匀。然后根据哈希值计算出数组中的位置（即桶的索引）。
  
   ```java
   int hash = hash(key);  // 计算键的哈希值
   int index = (n - 1) & hash;  // n 是数组的长度，通过哈希值找到对应的桶
   ```

2. **寻找插入位置**：根据计算出的索引找到对应的桶。如果桶中为空，则直接将键值对放入该位置。
   
3. **处理哈希冲突**：
   - 如果桶中已经存在元素，则会遍历链表或树，查找是否存在相同的键。
   - 如果找到了相同的键，则更新该键对应的值。
   - 如果没有找到相同的键，则将新节点插入到链表的头部。如果链表长度超过阈值（默认 8），则将链表转换为红黑树。

4. **扩容**：如果元素数量超过了 `HashMap` 的容量阈值（`threshold`），则会进行**扩容**操作，将数组大小扩展为原来的两倍，并重新哈希数组中的元素。

#### 2.2 **查找（get）操作**

`HashMap` 的 `get(K key)` 操作也是基于哈希值进行的，步骤如下：

1. **计算哈希值**：和 `put` 操作类似，先通过键的 `hashCode()` 方法计算出哈希值，再根据哈希值找到对应的桶。
  
   ```java
   int hash = hash(key);  // 计算哈希值
   int index = (n - 1) & hash;  // 找到桶的位置
   ```

2. **查找节点**：在找到的桶中，遍历链表或树，查找与传入键匹配的键。如果找到相同的键，返回对应的值；如果没有找到，则返回 `null`。

#### 2.3 **删除（remove）操作**

`HashMap` 的 `remove(K key)` 操作通过以下步骤进行：

1. **计算哈希值**：与 `put` 和 `get` 操作相同，先计算键的哈希值并定位到对应的桶。
2. **查找节点并删除**：遍历链表或树，找到与键匹配的节点，并将其从链表或树中删除。
3. **调整链表或树的结构**：如果删除后链表的长度小于某个阈值（默认 6），则红黑树会退化为链表，以减少存储和维护树的开销。

### 3. **HashMap 的哈希冲突**

哈希冲突指的是不同的键经过哈希函数计算后，得到相同的哈希值。这时，它们会被放入同一个桶中。

#### 3.1 **链表解决冲突**
- 当哈希冲突发生时，`HashMap` 会将新节点插入链表中，新的元素通常被放置在链表的头部。链表的查找时间复杂度是 **O(n)**，随着冲突增多，性能会逐渐下降。

#### 3.2 **红黑树解决冲突**
- 当链表的长度超过 8 时，链表会被转换成红黑树。这是为了提高性能，因为红黑树的查找、插入、删除操作的时间复杂度是 **O(log n)**，相比链表的线性查找要快得多。

#### 3.3 **哈希函数优化**
- `HashMap` 使用了哈希值的高位和低位来避免哈希冲突。为了让元素尽可能均匀地分布在哈希表中，`HashMap` 通过扰动函数对哈希值进行优化，减少冲突的发生。

### 4. **扩容机制**

`HashMap` 的扩容是当存储的键值对数量超过某个阈值（`threshold`）时触发的。默认情况下，`HashMap` 的容量是 **16**，负载因子是 **0.75**。也就是说，当 `HashMap` 中元素的数量达到 `16 * 0.75 = 12` 时，会触发扩容操作。

#### 4.1 **扩容过程**
1. `HashMap` 将容量扩展为原来的**两倍**。
2. 重新计算所有元素的哈希值，并将它们重新分配到新的桶中。这是一个相对较慢的过程，因为需要对所有元素重新哈希并移动它们。

#### 4.2 **负载因子**
- **负载因子（load factor）** 是 `HashMap` 的一个关键参数，表示哈希表在触发扩容之前能够填满的程度。默认负载因子是 0.75，这意味着当 `HashMap` 的元素数量达到容量的 75% 时，就会触发扩容。
- 较小的负载因子会减少哈希冲突的发生，提高查找效率，但会增加内存的使用量；较大的负载因子则会减少内存消耗，但可能会增加冲突的发生。

### 5. **HashMap 的线程安全性**

`HashMap` 是**非线程安全**的。如果多个线程同时访问并修改 `HashMap`，可能会导致数据不一致或其他问题。在并发环境下，可以使用以下几种方式来保证线程安全：

1. **使用 `Collections.synchronizedMap()`**：可以将 `HashMap` 包装为线程安全的 `Map`。
   
   ```java
   Map<String, String> syncMap = Collections.synchronizedMap(new HashMap<>());
   ```

2. **使用 `ConcurrentHashMap`**：`ConcurrentHashMap` 是线程安全的哈希表实现，适合在多线程环境下使用。

   ```java
   ConcurrentHashMap<String, String> concurrentMap = new ConcurrentHashMap<>();
   ```

### 6. **总结**

- **基本

数据结构**：`HashMap` 是基于**数组 + 链表 + 红黑树**的结构。每个桶存储一个链表或红黑树来解决哈希冲突。
- **性能优化**：通过链表、红黑树、哈希函数优化等机制，`HashMap` 实现了高效的查找、插入和删除操作。在链表长度超过一定阈值时，`HashMap` 会将链表转换为红黑树，以提升性能。
- **扩容机制**：`HashMap` 使用了负载因子来控制何时进行扩容，默认负载因子为 0.75，扩容会使容量翻倍并重新哈希所有元素。
- **线程安全**：`HashMap` 不是线程安全的，在多线程环境下应使用 `ConcurrentHashMap` 或其他同步机制。

通过这些机制，`HashMap` 在多数情况下能够实现接近 **O(1)** 的查找、插入和删除操作，是一种非常高效的键值对存储结构。