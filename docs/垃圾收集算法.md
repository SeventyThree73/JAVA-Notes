垃圾收集算法是 Java 虚拟机（JVM）中用于回收不再使用的对象所占用的内存的核心机制。不同的垃圾收集算法各有特点，适用于不同的内存管理场景。理解这些算法有助于优化应用程序的性能，减少内存占用和垃圾回收停顿时间。

### 1. **标记-清除算法（Mark-Sweep）**

#### 1.1 工作原理
- **标记阶段**：从根对象（GC Roots）开始，遍历整个对象图，标记所有仍然存活的对象。
- **清除阶段**：清理所有未标记的对象，并释放它们所占用的内存。

#### 1.2 优点
- 实现简单，适用于回收所有存活对象。
- 可以回收不定大小的对象，不需要额外的内存空间。

#### 1.3 缺点
- **内存碎片**：标记-清除算法在回收内存时并不会整理堆内存，回收后会产生大量的内存碎片。这些碎片会导致后续大对象分配失败，因为虽然有足够的总内存，但没有足够大的连续内存块。
- **效率问题**：由于要遍历整个堆，回收存活的对象，因此标记和清除阶段都可能会影响程序的运行时间，导致效率较低。

#### 示例图解：
```plaintext
[对象1][对象2][空闲][对象3][空闲][对象4]
标记阶段 -> 标记对象1、对象2、对象3、对象4
清除阶段 -> 清理空闲内存，释放未被标记的对象
```

### 2. **复制算法（Copying）**

#### 2.1 工作原理
将内存分为两个等大的区域，每次只使用其中一个区域。当垃圾回收时，扫描存活的对象，并将它们复制到未使用的区域，然后清空当前使用的区域。

#### 2.2 优点
- **高效的分配内存**：由于每次都在一个新的内存区域中分配对象，复制算法可以有效避免内存碎片问题，内存分配时只需要简单地移动指针。
- **实现简单**：复制后，整个空间可以一次性回收，不需要遍历或整理。

#### 2.3 缺点
- **内存浪费**：需要将堆空间分为两个部分，每次只使用其中一部分，这样会浪费一半的内存空间。
- **对象复制的开销**：每次回收时都要将存活的对象从一个区域复制到另一个区域，如果存活对象很多，复制的成本较高。

#### 应用场景
- 复制算法常用于年轻代的垃圾回收（如 Minor GC），因为在年轻代，大多数对象生命周期很短，存活对象少，因此复制成本较低。

#### 示例图解：
```plaintext
[对象1][对象2][空闲][对象3][空闲][对象4] -> 将存活的对象1、对象2、对象4复制到另一块内存区域
```

### 3. **标记-整理算法（Mark-Compact）**

#### 3.1 工作原理
与标记-清除算法类似，先标记出所有存活的对象。不同的是，在清除阶段，不是直接回收未标记的对象，而是将所有存活的对象压缩到内存的一端，最后清理掉边界外的所有内存。

#### 3.2 优点
- **解决了内存碎片问题**：通过将存活对象压缩到内存的一端，保证了回收后的内存空间是连续的，避免了内存碎片。
- **减少了大对象分配失败的风险**：由于整理内存后，空闲内存是连续的，大对象分配更加高效。

#### 3.3 缺点
- **对象移动的开销**：标记-整理算法需要移动存活的对象，因此如果存活对象较多，移动成本会较高。
- **相对复杂的实现**：相比于标记-清除算法，标记-整理算法的实现更加复杂。

#### 应用场景
- 适用于老年代的垃圾回收（如 Major GC 或 Full GC），因为老年代的对象存活时间长，存活对象多，频繁复制代价太高。

#### 示例图解：
```plaintext
[对象1][对象2][空闲][对象3][空闲][对象4] -> 将存活的对象整理到内存的一端 [对象1][对象2][对象4][空闲][空闲]
```

### 4. **分代收集算法（Generational Garbage Collection）**

#### 4.1 工作原理
分代收集算法基于对象的生命周期特点，将堆内存分为年轻代（Young Generation）和老年代（Old Generation），并根据不同代的特点选择不同的垃圾收集策略。

- **年轻代**：包括 Eden 区和两个 Survivor 区，适合采用**复制算法**，因为大多数新创建的对象生命周期很短，容易被回收。
- **老年代**：存放生命周期较长的对象，适合采用**标记-整理算法**或**标记-清除算法**，因为老年代的对象存活时间长，存活对象多。

#### 4.2 优点
- **针对性强**：不同代的对象有不同的生命周期特点，通过分代可以分别使用合适的垃圾回收算法，优化内存管理。
- **减少全堆回收的频率**：大多数对象在年轻代被回收，只有少量对象进入老年代，从而减少了老年代的垃圾回收频率，提升了性能。

#### 4.3 缺点
- **复杂性增加**：分代收集算法增加了内存管理的复杂性，需要更复杂的策略来处理不同代的垃圾回收。

#### 示例图解：
```plaintext
年轻代（Eden + Survivor） -> 对象存活一段时间后进入老年代 -> 老年代对象存活时间更长
```

### 5. **标记-清除-压缩算法（Mark-Sweep-Compact）**

这是 **标记-清除算法** 和 **标记-整理算法** 的组合。首先进行标记和清除操作，在进行对象清除后，将存活对象压缩到内存的另一端，释放空闲的内存区域。

#### 5.1 工作原理
1. **标记阶段**：从 GC Roots 开始标记所有存活对象。
2. **清除阶段**：清除所有未标记的对象，释放内存。
3. **压缩阶段**：将存活对象压缩到内存的一端，整理出连续的内存空间。

#### 优点
- 结合了标记-清除和标记-整理的优点，既可以清理内存，又可以解决内存碎片问题。

#### 缺点
- 由于多了压缩阶段，开销相对较大，适合在老年代中使用。

### 6. **垃圾收集器与算法的关系**

不同的垃圾收集器采用了不同的垃圾收集算法。以下是几种常见的垃圾收集器及其使用的算法：

- **Serial GC**：使用单线程，年轻代采用复制算法，老年代采用标记-整理算法。
- **Parallel GC**：类似于 Serial GC，但使用多线程并行处理。
- **CMS GC（Concurrent Mark-Sweep GC）**：年轻代采用复制算法，老年代采用标记-清除算法，适合低延迟应用。
- **G1 GC（Garbage First GC）**：一种较新的垃圾收集器，将堆划分为多个小块区域，并优先回收垃圾最多的区域，结合了标记-清除和标记-整理算法。

### 7. **垃圾回收算法的选择**

- **响应时间优先（低延迟）**：如果应用程序对暂停时间非常敏感，通常选择并发垃圾收集器，如 CMS 或 G1 GC。CMS 适合对老年代频繁回收的情况，而 G1 GC 适合堆内存较大的场景，并且可以通过预测性回收控制暂停时间。
  
- **吞吐量优先**：如果应用程序对吞吐量要求较高，如批处理程序，可以选择并行垃圾收集器（Parallel GC），这种收集器的回收速度快，适合多核 CPU 的环境。

### 总结

垃圾回收算法是 JVM 内存管理中的核心机制，不同的算法适用于不同的内存分配和回收场景。常见的算法有：
- **标记-清除算法**：简单直接，但可能产生内存碎片。
- **复制算法**：高效分配内存，适合年轻代回收，但内存利用率较低。
- **标记-整理算法**：适合老年代回收，解决了内存碎片问题，但移动对象的开销较大。
- **分代收集算法**：根据对象的生命周期特点进行垃圾回收，结合多种算法优化性能。

通过理解这些算法的原理和适用场景，可以更好地优化 Java 应用的性能，减少内存开销和垃圾回收对程序运行的影响。