**CMS（Concurrent Mark-Sweep）收集器**是 Java 虚拟机（JVM）中用于老年代的垃圾收集器，其目标是尽量减少垃圾回收时应用程序的停顿时间（Stop-the-World）。CMS 收集器适用于对响应时间敏感的应用，比如互联网应用中的服务端应用。CMS 的垃圾回收过程分为多个阶段，其中包括并发的垃圾回收过程和短暂的 "Stop-the-World" 阶段。下面我们详细讲解 CMS 的垃圾收集过程。

![](/src/CMS收集器垃圾收集过程.png)

### 1. **CMS 垃圾收集器的基本原理**

CMS 收集器基于**标记-清除算法（Mark-Sweep Algorithm）**，其核心思想是：
1. 标记存活的对象。
2. 清除未标记的对象，回收它们所占的内存。

为了减少应用程序的停顿时间，CMS 收集器在标记和清除过程中尽量与应用程序并发执行，因此垃圾回收的开销主要发生在后台。

### 2. **CMS 收集器的垃圾收集过程**

CMS 的垃圾回收过程分为四个主要阶段：**初始标记**、**并发标记**、**重新标记**、**并发清除**。其中，初始标记和重新标记会短暂暂停应用程序（Stop-the-World），而并发标记和并发清除则与应用程序并发执行。

#### 2.1 **初始标记（Initial Marking）**

- **描述**：初始标记阶段用于标记**GC Roots** 直接引用的对象。
- **特点**：这个阶段会短暂停顿应用程序执行，因为 GC 需要确保从 GC Roots 开始的对象引用是准确的。
- **耗时**：初始标记阶段非常短，因为只需要标记 GC Roots 直接引用的对象。
- **STW（Stop-the-World）**：需要暂停应用程序。

#### 2.2 **并发标记（Concurrent Marking）**

- **描述**：并发标记阶段是从 GC Roots 开始递归地标记所有可达的对象，即标记所有可以通过 GC Roots 直接或间接引用到的存活对象。
- **特点**：这个阶段与应用程序并发执行，应用程序可以继续运行，GC 在后台执行标记操作。
- **耗时**：并发标记阶段可能较长，因为需要遍历整个堆，标记存活的对象。
- **STW**：无需暂停应用程序。

#### 2.3 **重新标记（Remarking）**

- **描述**：重新标记阶段用于修正并发标记阶段中，由于应用程序运行而产生的对象引用变化。因为并发标记阶段与应用程序同时进行，应用程序可能会修改对象引用关系，导致一些对象未被正确标记，因此需要重新标记来确保标记准确。
- **特点**：这个阶段会再次暂停应用程序执行，并重新扫描部分对象以修正标记结果。
- **耗时**：重新标记阶段的耗时通常较短，但比初始标记稍长。
- **STW**：需要暂停应用程序。

#### 2.4 **并发清除（Concurrent Sweeping）**

- **描述**：并发清除阶段清理所有未标记的对象，回收它们所占用的内存。这一步是基于**标记-清除算法**的清除过程。
- **特点**：这个阶段与应用程序并发执行，应用程序可以继续运行。
- **耗时**：清除阶段耗时较长，因为它需要遍历整个堆，清理不可达对象。
- **STW**：无需暂停应用程序。

#### 2.5 **并发重置（Concurrent Reset）**
- **描述**：CMS 完成一次 GC 后，会进入并发重置阶段，重置 CMS 收集器的状态，为下一次 GC 做准备。
- **特点**：这个阶段也与应用程序并发执行。
- **STW**：无需暂停应用程序。

### 3. **CMS 收集器的运行流程**

CMS 收集器的运行流程总结如下：

1. **初始标记阶段**（STW）：
   - 标记与 GC Roots 直接关联的对象。
   - 停顿时间短。

2. **并发标记阶段**（与应用程序并发）：
   - 从 GC Roots 开始递归标记所有可达对象。
   - 与应用程序并发执行，无需暂停。

3. **重新标记阶段**（STW）：
   - 修正并发标记过程中应用程序的引用关系变动。
   - 停顿时间稍长，但仍然较短。

4. **并发清除阶段**（与应用程序并发）：
   - 清理所有未标记的对象，回收内存。
   - 与应用程序并发执行，无需暂停。

5. **并发重置阶段**（与应用程序并发）：
   - 重置 CMS 收集器的内部状态，为下一次回收做准备。

### 4. **CMS 收集器的优点**

- **低延迟**：CMS 收集器的设计目标是减少垃圾回收对应用程序的停顿时间（Stop-the-World 时间）。在多数时间内，CMS 是并发执行的，不会中断应用程序的运行，因此适合对响应时间敏感的应用程序。
  
- **并发执行**：CMS 大部分工作（标记和清除）与应用程序并发执行，应用程序可以继续运行，不需要长时间的停顿。

### 5. **CMS 收集器的缺点**

虽然 CMS 收集器在降低延迟方面非常有效，但它也有一些显著的缺点：

#### 5.1 **内存碎片问题**
- **描述**：CMS 使用的是**标记-清除算法**，而不是**标记-整理算法**。因此，CMS 在清理未标记对象时，并不会对存活对象进行整理，这会导致堆中出现**内存碎片**。
- **影响**：内存碎片会使得 CMS 无法为大对象分配连续的内存块，从而导致内存分配失败，进而引发 **Full GC**。
- **解决方案**：JVM 提供了一个参数 `-XX:+UseCMSCompactAtFullCollection`，在 Full GC 时进行内存整理，减少碎片的影响。但这种方式会增加 Full GC 的停顿时间。

#### 5.2 **"Concurrent Mode Failure" 问题**
- **描述**：由于 CMS 是与应用程序并发运行的，可能在 CMS 回收完成之前，老年代已经没有足够的空间分配新的对象，导致**并发模式失败（Concurrent Mode Failure）**。此时，JVM 会触发一次 **Full GC** 来进行垃圾回收。
- **影响**：Full GC 会造成应用程序的长时间停顿，这是 CMS 收集器的一个严重问题。
- **解决方案**：可以通过增大老年代的内存大小（通过 `-XX:CMSInitiatingOccupancyFraction` 参数调整）来降低 Concurrent Mode Failure 的发生概率。

#### 5.3 **较高的 CPU 使用率**
- **描述**：CMS 收集器的并发性意味着它在回收过程中会与应用程序争夺 CPU 资源。特别是在并发标记和并发清除阶段，CMS 需要消耗额外的 CPU 资源，导致应用程序的 CPU 使用率上升。
- **影响**：在 CPU 资源有限的系统中，CMS 可能导致应用程序性能下降，特别是在并发回收期间。
- **解决方案**：可以通过限制 CMS 使用的线程数量（通过 `-XX:ConcGCThreads` 参数）来控制 CPU 资源的占用。

### 6. **CMS 收集器的参数调优**

CMS 收集器提供了一些参数，用于控制其行为和性能优化。常见的调优参数包括：

- **`-XX:+UseConcMarkSweepGC`**：启用 CMS 收集器。
- **`-XX:CMSInitiatingOccupancyFraction=<N>`**：设置老年代在使用了多少百分比的内存后开始进行 CMS 回收。默认是 68%，即当老年代使用率达到 68% 时开始垃圾回收。较低的值可以减少 Concurrent Mode Failure，但会增加回收频率。
- **`-XX:+UseCMSCompactAtFullCollection`**：在 Full GC 时对老年代进行内存碎片整理，减少碎片的影响。
- **`-XX:ConcGCThreads=<N>`**：设置 CMS 并发垃圾回收的线程数。默认根据 CPU 数量确定，但可以通过该参数进行手动调整。
- **`-XX:+CMSScavengeBeforeRemark`**：在 CMS 回收之前，执行一次 Minor GC，以减少老年代被新生代对象填满的概率。

### 7. **CMS 收集器的替代：G1 GC**

尽管 CMS 收集器在许多应用中表现良好，但由于其内存碎片和并发模式失败的问题，

**G1 GC**（Garbage First）收集器被设计为 CMS 的替代品。G1 GC 通过区域化内存管理和并发垃圾回收，能够在较低延迟的情况下解决内存碎片问题，并且有更强大的控制暂停时间的能力。

### 总结

CMS 收集器是一种**低延迟**的垃圾收集器，主要用于老年代的垃圾回收。其通过标记-清除算法实现垃圾回收，并采用了并发回收机制，大大减少了应用程序的停顿时间。CMS 的工作流程包括**初始标记**、**并发标记**、**重新标记**和**并发清除**，其中并发阶段与应用程序同时执行，有效降低了 GC 对应用的影响。

尽管 CMS 在降低 GC 停顿时间方面表现优异，但其缺点也比较明显，如**内存碎片**、**并发模式失败**以及较高的 CPU 使用率。随着 G1 收集器的出现，CMS 在一些新系统中逐渐被 G1 所取代。然而，CMS 仍然在许多对延迟敏感的应用中使用，尤其是在内存较大的服务端应用中。