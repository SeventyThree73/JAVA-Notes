# Java面试知识点总结
> 制作： 三尺七十  
> 参考：  
<https://www.bilibili.com/video/BV1sP46e2ERD>  
<https://chatgpt.com/>

## 目录
1. [JDK，JRE，JVM三者之间的关系](#jdk-jre-jvm-三者之间的关系)
2. [创建对象方式](#创建对象方式)
3. [final、finally 和 finalize 的区别](#final-finally-finalize的区别)
4. [对于 == 和 equals 的区别](#对于--和-equals-的区别)
5. [两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗](#两个对象的-hashcode-相同则-equals-也一定为-true-吗)
6. [对于 & 和 && 的区别](#对于--和--的区别)
7. [Java 中的参数传递时传值呢还是传引用](#java-中的参数传递时传值呢还是传引用)
8. [什么是 Java 的序列化，如何实现 Java 的序列化](#什么是-java-的序列化如何实现-java-的序列化)
9. [Java 中的反射是什么意思](#java-中的反射是什么意思)
10. [反射的应用场景有哪些？反射有什么优缺点？](#反射的应用场景有哪些反射有什么优缺点)
11. [怎么实现动态代理](#怎么实现动态代理)
12. [String 为什么要设计为不可变类](#string-为什么要设计为不可变类)
13. [String、StringBuilder、StringBuffer 的区别](#stringstringbuilderstringbuffer-的区别)
14. [String str = "i" 与 String str = new String("i") 一样吗](#string-str--i-与-string-str--new-stringi-一样吗)
15. [接口和抽象类有什么区别](#接口和抽象类有什么区别)
16. [浅拷贝和深拷贝](#浅拷贝和深拷贝)
17. [Overload、Override、Overwrite的区别](#overloadoverrideoverwrite的区别)
18. [Exception和Error有什么区别](#exception和error有什么区别)
19. [Java中的IO流的分类](#java中的io流的分类)
20. [常见的异常类有哪些](#常见的异常类有哪些)
21. [对JVM内存模型的理解](#对jvm内存模型的理解)
22. [对象创建的过程](#对象创建的过程)
23. [什么是指针碰撞和空闲列表](#什么是指针碰撞和空闲列表)
24. [JVM创建对象时，堆会发生抢占吗](#jvm创建对象时堆会发生抢占吗)
25. [对象的内存布局](#对象的内存布局)
26. [如何判断对象仍然存活](#如何判断对象仍然存活)
27. [垃圾收集算法](#垃圾收集算法)
28. [详细说一下 CMS 收集器的垃圾收集过程](#详细说一下-cms-收集器的垃圾收集过程)
29. [G1 垃圾收集器](#g1-垃圾收集器)
30. [对象一定分配在堆中吗](#对象一定分配在堆中吗)
31. [有哪些常见集合](#有哪些常见集合)
32. [ArrayList和LinkedList有什么区别](#arraylist和linkedlist有什么区别)
33. [ArrayList的扩容机制](#arraylist的扩容机制)
34. [ArrayList中为什么用transient修饰数组](#arraylist中为什么用transient修饰数组)
35. [什么是快速失败(fail-fast)和安全失败(fail-safe)](#什么是快速失败fail-fast和安全失败fail-safe)
36. [怎么保证 ArrayList线程安全](#怎么保证-arraylist线程安全)
37. [CopyOnWriteArrayList 了解多少](#copyonwritearraylist-了解多少)
38. [HashMap的数据结构](#hashmap的数据结构)
39. [对红黑树的理解](#对红黑树的理解)
40. [红黑树怎么保持平衡的](#红黑树怎么保持平衡的)


0. [A and B](#a-and-b)

## **JDK, JRE, JVM 三者之间的关系**

### 1. **JDK（Java Development Kit，Java 开发工具包）**：
   - **作用**：JDK 是用于开发 Java 应用程序的工具包，包含了编写、编译、运行 Java 程序所需的工具。

### 2. **JRE（Java Runtime Environment，Java 运行环境）**：
   - **作用**：JRE 是用于运行 Java 应用程序的环境，它提供了 Java 程序运行所需的库、类和资源。

### 3. **JVM（Java Virtual Machine，Java 虚拟机）**：
   - **作用**：JVM 是 Java 的核心部分，它负责执行字节码（即编译后的 `.class` 文件）。JVM 提供跨平台能力，使得 Java 程序能够在不同操作系统上运行。

### 三者关系总结：
- **JVM** 是运行 Java 字节码的核心。
- **JRE** 包含 JVM 和标准类库，用于执行 Java 应用程序。
- **JDK** 包含 JRE 及开发工具，用于编写、编译和调试 Java 程序。

用图来解释的话：
```
JDK = JRE + 开发工具
JRE = JVM + 类库
```

JDK → JRE → JVM，开发使用 JDK，运行时只需 JRE，而核心执行由 JVM 负责。

[回到目录](#目录)


## **创建对象方式**

### 1. **使用 `new` 关键字**

### 2. **使用 `Class.newInstance()` 方法**

### 3. **使用 `Constructor.newInstance()` 方法**

### 4. **使用 `clone()` 方法**

### 5. **使用反序列化（Deserialization）**

### 总结：
- **常用方法**：`new` 关键字最常用，简洁高效。
- **反射方法**：`Class.newInstance()` 和 `Constructor.newInstance()` 用于动态加载类和创建对象。
- **特殊方法**：`clone()` 用于复制对象，`反序列化` 用于重建对象。

每种方式适用于不同的场景，最常见的仍然是使用 `new` 关键字直接创建对象。

[回到目录](#目录)

## **final, finally, finalize的区别**

### 1. **`final` 关键字**
   `final` 是一个关键字，具有不同的含义，具体取决于它修饰的内容：

### 2. **`finally` 关键字**
   `finally` 是 Java 异常处理中的一部分，用来定义一个代码块，无论是否发生异常，这个代码块中的代码都会执行。

### 3. **`finalize()` 方法**
   `finalize()` 是 Java 中的一个方法，用于对象在垃圾回收前执行清理操作。它属于 `Object` 类，所有对象在垃圾回收前，虚拟机会尝试调用这个方法。

**总结**：`finalize()` 是一种在对象被垃圾回收前调用的机制，但由于其不可靠性和不可预测性，通常不推荐使用。

[回到目录](#目录)

## **对于 == 和 equals 的区别**
1. **`==`**：
- 对于**基本数据类型**，`==` 直接比较值是否相等
- 对于**引用类型**，`==` 比较的是两个对象的内存地址是否相同
2. **`equals()`**：
- 默认也是比较内存地址，但通常会被类重写用于比较对象的内容（如 `String` 类）。

[回到目录](#目录)

## 两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗
如果两个对象的 `hashCode()` 相同，**它们未必通过 `equals()` 相等**。这意味着不同对象可能有相同的 `hashCode()`，这种现象称为**哈希冲突**。

[回到目录](#目录)


## 对于 & 和 && 的区别
### **按位与 &（用于位运算）**
- 当 `&` 用于**整数类型**时，它是**按位与运算符**，用于对每一位进行比较，只有当两个操作数的同一位都是 `1` 时，该位结果才是 `1`，否则结果是 `0`。
### **逻辑与 &&（用于布尔逻辑运算）**
- 当 `&` 用于**布尔值**时，它是**逻辑与运算符**，只有当两个操作数都为 `true` 时，结果才是 `true`。
- 与 `&&` 的区别在于：`&` **不会短路**，即它总是会对两个操作数都进行求值。

[回到目录](#目录)

## Java 中的参数传递时传值呢还是传引用

### 1. **基本数据类型的传值**
对于 **基本数据类型**（如 `int`, `double`, `char`, `boolean` 等），Java 通过**按值传递**的方式传递参数，即传递的是实际值的副本。

### 2. **引用类型的传值**
对于 **引用类型**（如对象、数组等），Java 仍然是**按值传递**。但是，传递的**值是对象引用的副本**。这意味着方法得到的是**对象的内存地址的副本**，通过这个副本仍然可以修改对象的内部状态，但无法改变对象的引用本身。

[回到目录](#目录)

## 什么是 Java 的序列化，如何实现 Java 的序列化？
（Serialization）是将对象的状态转换为字节流（byte stream）的过程，以便该对象可以被保存到文件、数据库，或者通过网络进行传输。序列化后的对象可以稍后通过反序列化（Deserialization）恢复为原始对象。

序列化的用途包括：
1. **持久化存储**：将对象保存到文件中或数据库中，以便在未来恢复。
2. **网络传输**：将对象通过网络发送到远程主机，再通过反序列化恢复对象。
3. **缓存**：将对象缓存到内存之外的地方，以减少计算开销。

### 如何实现 Java 的序列化？

在 Java 中，实现序列化的步骤非常简单，只需要让对象所属的类实现 `Serializable` 接口。这是一个**标记接口**，即它不包含任何方法，只是标记某个类的实例是可序列化的。

#### 实现步骤：

1. **实现 `Serializable` 接口**：
   类实现 `Serializable` 接口，标记该类及其所有字段可以被序列化。
   
2. **使用 `ObjectOutputStream` 和 `ObjectInputStream`**：
   - 使用 `ObjectOutputStream` 将对象写入到文件（或其他输出流）中。
   - 使用 `ObjectInputStream` 从文件（或其他输入流）中读取对象并反序列化。

[回到目录](#目录)

## Java 中的反射是什么意思
是指程序在运行时动态地获取类的信息，并且能够操作类、方法、字段等。这使得程序能够在不知道类的情况下，动态地创建对象、调用方法、访问字段等。反射是 Java 提供的一种非常强大的机制，可以帮助程序实现高度的灵活性。

### 反射的用途
- **动态加载类**：在运行时，根据类名加载类，而无需在编译时知道具体的类。
- **访问类的私有成员**：即使是私有字段、方法，也可以通过反射访问和修改。
- **动态调用方法**：可以在运行时根据方法名动态地调用方法。
- **创建对象**：可以在不知道类名的情况下，动态创建对象实例。
- **框架和库的基础**：很多 Java 框架（如 Spring、Hibernate 等）广泛使用反射来实现依赖注入、对象关系映射等功能。

### 反射的核心类
Java 的反射机制主要通过以下几个类来实现，它们位于 `java.lang.reflect` 包中：
- **`Class`**：代表一个类或接口，通过它可以获取类的元数据。
- **`Field`**：代表类的成员变量（字段）。
- **`Method`**：代表类的方法。
- **`Constructor`**：代表类的构造函数。

[回到目录](#目录)

## 反射的应用场景有哪些？反射有什么优缺点？
### Java 反射的应用场景

反射是一种非常强大的工具，它的灵活性使得它在许多场景下都非常有用。以下是反射的一些常见应用场景：

#### 1. **框架开发**
   - **依赖注入**：如 Spring 框架，通过反射动态地实例化对象并设置其属性，允许在运行时根据配置文件或注解注入依赖，而不需要硬编码。
   - **对象关系映射（ORM）**：如 Hibernate 通过反射来将数据库表映射为 Java 对象，并通过反射机制将对象的属性与数据库列进行映射。

#### 2. **动态代理**
   - Java 的动态代理广泛使用反射机制来生成代理类，并动态地为目标对象调用方法。例如，AOP（面向切面编程）使用反射来在方法调用前后插入代码逻辑。

#### 3. **测试框架**
   - 像 JUnit 和 TestNG 等测试框架使用反射来查找和调用标记为 `@Test` 的方法。通过反射，可以动态地执行这些方法，无需显式调用。

#### 4. **序列化/反序列化框架**
   - 序列化框架（如 Jackson、Gson）使用反射来解析对象，并将其转换为 JSON、XML 等格式，或者将 JSON、XML 等反序列化为 Java 对象。通过反射可以动态获取类的字段和类型信息。

#### 5. **插件机制**
   - 反射可以用于实现动态加载类的机制，在运行时根据类名加载类和调用方法。例如，Java 的 SPI（Service Provider Interface）机制就是使用反射来动态加载服务实现。

#### 6. **代码生成和字节码操作**
   - 某些工具（如 Javassist 和 ASM）使用反射来生成或修改字节码，动态地生成类或方法。在构建复杂的库或框架时，反射帮助实现动态代码生成的能力。

#### 7. **开发调试工具**
   - 反射可以用于构建调试工具，例如通过反射获取类的结构信息，并动态地打印对象的属性和值。它也可以用于创建类似 `toString()` 的方法，动态生成对象的字符串表示。

---

### 反射的优点

1. **灵活性**：
   - 反射可以在运行时动态获取类的信息、调用方法、访问字段等。这使得代码更加灵活，能够处理在编译时不确定的类和方法。

2. **解耦合**：
   - 通过反射，类之间的依赖可以大大减少。例如，通过反射可以动态实例化对象，而不需要在编译时确定具体的类。

3. **框架和库的基础**：
   - 反射为很多流行的 Java 框架和库（如 Spring、Hibernate、JUnit 等）提供了实现基础，帮助实现依赖注入、代理、动态代理等功能。

4. **动态代码执行**：
   - 反射使得在运行时可以根据需要动态执行代码，而无需编译时提前知道某个方法的存在。这在处理动态类加载、插件机制等场景时非常有用。

---

### 反射的缺点

1. **性能开销**：
   - 反射的操作（如动态获取类信息、调用方法等）涉及运行时的类型检查和安全性检查，因此相比于直接调用方法，性能较低。在性能敏感的场景中频繁使用反射可能会导致性能下降。

2. **安全风险**：
   - 反射可以绕过 Java 的访问控制机制，例如，可以通过反射访问和修改私有字段或方法。这可能导致代码被滥用，进而带来安全隐患，尤其是在不受信任的环境中。

3. **可维护性差**：
   - 反射使得代码的可读性和可维护性下降。因为反射是动态执行的，编译时不会捕捉类型错误或调用错误。问题通常在运行时才暴露，这使得调试和维护更加困难。

4. **失去编译时的类型检查**：
   - 反射通过字符串和 `Class` 对象来操作类、方法、字段等，而不是通过显式的类型引用。这意味着反射绕过了编译时的类型安全检查，可能会导致运行时异常（如 `NoSuchMethodException` 或 `IllegalAccessException`），增加了错误的可能性。

5. **代码复杂度增加**：
   - 使用反射会增加代码的复杂性，特别是在涉及到复杂的动态代理和类加载时，代码的逻辑变得更难以理解和管理。

[回到目录](#目录)

## 怎么实现动态代理

在 Java 中，动态代理是一种设计模式，它允许你在运行时创建代理对象，并动态地决定代理对象的行为。动态代理通常用于**面向切面编程（AOP）**、**日志记录**、**事务管理**、**权限控制**等场景。Java 提供了内置的动态代理机制，通过 `java.lang.reflect.Proxy` 类和 `InvocationHandler` 接口可以实现。

### 动态代理的工作原理

- **代理对象**：在运行时生成的对象，代理另一个对象的行为。
- **InvocationHandler 接口**：处理代理对象的方法调用。每次代理对象的方法被调用时，`InvocationHandler` 接口的 `invoke()` 方法都会被调用，以执行相关的逻辑。
- **Proxy 类**：用于动态创建代理对象。

[回到目录](#目录)

## String 为什么要设计为不可变类

Java 中的 `String` 类设计为不可变类（Immutable Class），是出于多方面的考虑，包括安全性、性能优化和设计的简洁性等。不可变性意味着一旦 `String` 对象被创建，它的值就无法被改变。每当对 `String` 对象进行任何修改操作时，都会创建一个新的 `String` 对象。

### `String` 不可变性的原因：

1. **安全性**：防止敏感数据（如文件路径、URL、密码等）被修改，确保系统安全。
2. **线程安全**：多个线程可以安全地共享相同的 `String` 对象，无需额外同步。
3. **常量池优化**：实现字符串常量池，减少内存使用，提升性能。
4. **性能提升**：通过缓存 `hashCode` 等操作优化性能，特别是对于哈希表的使用。
5. **设计简洁**：不可变对象简化了编程中的状态管理，使得代码更可靠和可维护。

[回到目录](#目录)

## String、StringBuilder、StringBuffer 的区别

### 区别总结

| 特性                 | `String`                | `StringBuilder`        | `StringBuffer`         |
|----------------------|-------------------------|------------------------|------------------------|
| **可变性**            | 不可变                  | 可变                   | 可变                   |
| **线程安全性**        | 线程安全                | 线程不安全             | 线程安全               |
| **性能**              | 低（每次修改创建新对象）| 高（单线程环境高效）   | 较低（由于同步，性能较低） |
| **适用场景**          | 字符串内容不变的场景    | 单线程环境下的频繁字符串操作 | 多线程环境下的频繁字符串操作 |
| **底层实现**          | 字符串常量池，数组      | 可变字符数组           | 同步的可变字符数组     |

总结来说，`String` 是不可变的，而 `StringBuilder` 和 `StringBuffer` 是可变的。在单线程环境下，`StringBuilder` 性能优于 `StringBuffer`，而在多线程环境下，`StringBuffer` 提供了线程安全的字符串操作。

[回到目录](#目录)

## String str = "i" 与 String str = new String("i") 一样吗

- `String str = "i";` 使用字符串常量池来避免重复创建相同内容的字符串对象，这种方式在内存和性能上更高效。
- `String str = new String("i");` 每次都会在堆上创建一个新的 `String` 对象，即使字符串内容相同，两个对象的引用也不相等。

因此，在不需要特别创建新对象的情况下，建议使用 `String str = "i";` 的方式，因为它更高效且能复用常量池中的字符串。

[回到目录](#目录)

## 接口和抽象类有什么区别

### 1. **设计意图**

- **接口（Interface）**：接口定义了一组**行为的规范**，描述了实现类需要提供哪些方法。接口用于定义类之间的契约，它不关心实现细节，只关心行为。接口强调**功能**，并且支持**多继承**（一个类可以实现多个接口）。

- **抽象类（Abstract Class）**：抽象类是用于提供一组共享的属性和方法的基类，强调**类的共性**。它可以包含抽象方法（无实现的）和具体方法（有实现的），用于提供一些通用功能。抽象类更像是**代码的复用机制**，并且只能被**单继承**。

### 2. **语法和功能特性对比**

| 比较项                   | **接口（Interface）**                        | **抽象类（Abstract Class）**                 |
|--------------------------|----------------------------------------------|----------------------------------------------|
| **方法实现**              | 只能包含抽象方法（直到 Java 8 之前）         | 可以包含抽象方法和非抽象方法（即具体实现）   |
| **字段**                  | 只能包含 `public static final` 常量           | 可以包含实例变量（字段）和常量                |
| **构造方法**              | 没有构造方法                                  | 可以有构造方法（但不能直接实例化）            |
| **继承**                  | 一个类可以实现多个接口（多重继承）            | 一个类只能继承一个抽象类（单继承）            |
| **默认方法**              | Java 8 开始支持默认方法（`default`）           | 可以定义具体方法（非抽象方法）               |
| **访问修饰符**            | 方法默认是 `public`，不可使用其他修饰符         | 可以使用 `public`, `protected`, `private` 等 |
| **使用场景**              | 用于定义行为的契约，实现多态行为               | 用于提供公共的功能实现，避免重复代码           |
| **多继承支持**            | 可以通过实现多个接口来支持多继承               | 只能通过继承单个抽象类                       |
| **抽象方法的强制性**      | 接口中的所有方法（默认方法除外）都必须被实现   | 抽象类中的抽象方法必须被子类实现             |


[回到目录](#目录)

## 浅拷贝和深拷贝

- **浅拷贝**：只复制基本类型和引用，但不会复制引用指向的对象，适合简单对象的场景。
- **深拷贝**：递归复制所有内容，确保拷贝对象完全独立，适合复杂的对象结构和需要独立对象的场景。

[回到目录](#目录)

## Overload、Override、Overwrite的区别

- **Overload（重载）**：是在同一个类中，允许使用相同的方法名来处理不同的参数组合。
- **Override（重写）**：是在子类中提供与父类方法相同签名的方法，实现不同的功能。
- **Overwrite（覆盖）**：通常与文件或数据操作相关，用于表示覆盖已有的内容，与面向对象编程无关。

在 Java 中，最常见的概念是**方法重载（Overload）**和**方法重写（Override）**，分别用于提供多种方法实现和修改父类方法的行为。

[回到目录](#目录)

## Exception和Error有什么区别

- **`Exception`**：表示可以预料并且可以通过程序处理的异常，分为受检异常和运行时异常。程序应该合理处理这些异常，确保程序能够继续运行。
- **`Error`**：表示无法恢复的系统级错误，通常由 JVM 引发。程序不应该捕获这些错误，因为它们意味着系统已经进入了不可恢复的状态。

### **受检异常与非受检异常**

- **受检异常（Checked Exception）**：
  - 受检异常是编译器强制要求处理的异常。如果方法中抛出受检异常，必须在方法签名中声明 `throws`，或者用 `try-catch` 来捕获。
  - 继承自 `Exception`，但不包括 `RuntimeException` 的异常。
  - 例子：`IOException`、`SQLException`。

- **非受检异常（Unchecked Exception）**：
  - 非受检异常是指不需要强制处理的异常。这类异常通常是由编程错误引发的，程序可以选择不捕获。
  - 继承自 `RuntimeException`，如 `NullPointerException`、`ArrayIndexOutOfBoundsException`。
  - `Error` 也是非受检异常，但其严重性更高，表示 JVM 层级的问题。

[回到目录](#目录)

## Java中的IO流的分类

Java 中的 IO 流可以根据多种方式进行分类：
1. **按数据类型**：字节流处理原始字节数据，字符流处理字符数据。
2. **按流的方向**：输入流用于从外部读取数据，输出流用于向外部写入数据。
3. **按是否有缓冲**：缓冲流使用内存缓冲区提高 IO 操作的性能。
4. **按功能**：数据流处理基本类型，对象流处理对象的序列化与反序列化，转换流用于字节与字符流的转换。

[回到目录](#目录)

## 常见的异常类有哪些

- **受检异常**：如 `IOException`、`SQLException`，必须在编译时处理，通过 `try-catch` 捕获或使用 `throws` 声明。
- **运行时异常（非受检异常）**：如 `NullPointerException`、`ArrayIndexOutOfBoundsException`，是程序运行时可能遇到的常见问题，通常是由程序逻辑错误导致的，不强制要求处理。
- **错误（`Error`）**：如 `OutOfMemoryError`、`StackOverflowError`，表示严重的系统错误，通常无法通过应用程序进行处理。

### **常见的异常类总结**

| **异常类**                         | **描述**                                                                 |
|------------------------------------|--------------------------------------------------------------------------|
| **`IOException`**                  | 输入/输出异常的通用父类，文件读取、写入失败时抛出。                          |
| **`FileNotFoundException`**        | 文件未找到时抛出。                                                         |
| **`EOFException`**                 | 输入流到达末尾时抛出。                                                     |
| **`SQLException`**                 | 数据库操作异常时抛出。                                                     |
| **`ClassNotFoundException`**       | 试图加载的类不存在时抛出。                                                 |
| **`InterruptedException`**         | 线程被中断时抛出。                                                         |
| **`NullPointerException`**         | 访问 `null` 对象的成员时抛出。                                             |
| **`ArrayIndexOutOfBoundsException`** | 数组索引超出范围时抛出。                                                   |
| **`ArithmeticException`**          | 算术运算错误（如除以零）时抛出。                                           |
| **`ClassCastException`**           | 类型转换错误时抛出。                                                       |
| **`IllegalArgumentException`**     | 方法参数非法时抛出。                                                       |
| **`NumberFormatException`**        | 数字格式错误时抛出。                                                       |
| **`IllegalStateException`**        | 方法调用时机不正确时抛出。                                                 |
| **`UnsupportedOperationException`** | 调用不支持的操作时抛出。                                                   |
| **`OutOfMemoryError`**             | JVM 内存不足时抛出。                                                       |
| **`StackOverflowError`**           | 方法递归太深导致栈溢出时抛出。     

[回到目录](#目录)

## 对JVM内存模型的理解

### 内存模型总结图

| **区域**                | **描述**                                                                                                                                     | **线程访问**  | **可能抛出的异常**              |
|-------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|---------------|------------------------------|
| **程序计数器**           | 指示当前线程正在执行的字节码指令的地址，线程私有                                                                                           | 线程私有      | 无                           |
| **Java 虚拟机栈**        | 存储局部变量表、操作数栈和方法出口等信息，主要用于方法调用                                                                                  | 线程私有      | `StackOverflowError`、`OutOfMemoryError` |
| **本地方法栈**           | 存储本地方法的执行状态信息，类似于 JVM 栈，但用于本地方法                                                                                   | 线程私有      | `StackOverflowError`、`OutOfMemoryError` |
| **堆**                  | 存储对象实例和数组，垃圾回收主要作用于此区域                                                                                               | 线程共享      | `OutOfMemoryError`           |
| **方法区**               | 存储类信息、常量、静态变量和即时编译后的代码                                                                                               | 线程共享      | `OutOfMemoryError`           |
| **运行时常量池**         | 方法区的一部分，存储类加载时的常量和运行时生成的常量                                                                                         | 线程共享      | `OutOfMemoryError`           |
| **直接内存**             | 通过 NIO 分配的堆外内存，提升 I/O 操作的效率                                                                                                | 线程共享      | `OutOfMemoryError`           |

### 总结
- **程序计数器**、**JVM 栈**、**本地方法栈**是线程私有的，分别用于存储字节码执行地址、方法调用信息以及本地方法状态。
- **堆**和**方法区**是线程共享的，堆用于存储对象实例和数组，方法区存储类的元数据信息。
- **直接内存**用于高效的 I/O 操作，属于堆外内存，由操作系统管理。

[回到目录](#目录)

## 对象创建的过程

### 详细过程：
1. **类加载**：JVM 首先会检查 `Person` 类是否已经加载，如果没有，则通过类加载器加载该类。
2. **内存分配**：在堆上为 `Person` 对象分配内存，并为 `name` 和 `age` 字段分配空间。
3. **设置默认值**：将 `name` 初始化为 `null`，将 `age` 初始化为 `0`。
4. **调用构造器**：调用 `Person` 构造器，将 `name` 字段设置为 `"Alice"`，`age` 字段设置为 `25`。
5. **返回引用**：将新创建的对象引用赋值给变量 `person`，此时对象创建完成。

[回到目录](#目录)

## 什么是指针碰撞和空闲列表

### 总结

- **指针碰撞**是一种高效的内存分配方式，但要求堆内存规整，没有碎片化，适合配合**复制算法**或**标记-整理算法**使用。
- **空闲列表**适用于堆内存有碎片的情况，通过维护一个空闲块链表来管理内存，适合配合**标记-清除算法**使用。

[回到目录](#目录)

## JVM创建对象时，堆会发生抢占吗

### 总结

- 在 JVM 中，堆是**线程共享**的内存区域，多个线程可能同时尝试在堆上分配内存，理论上会发生**堆抢占**，导致线程竞争。
- JVM 使用了 **TLAB线程本地分配缓冲区** 机制，来减少线程之间的堆内存分配冲突。TLAB 是线程私有的，通常用于分配小对象。大对象或超出 TLAB 容量的对象仍需要直接在堆上分配，可能导致线程间的竞争。
- 通过**逃逸分析**和**对象合并优化**等手段，JVM 可以进一步优化对象分配，减少全局堆的使用，从而降低堆抢占的发生。

JVM 内存分配机制通过多种方式减少了多线程环境下的内存竞争，从而提升了对象分配的效率和程序的整体性能。

[回到目录](#目录)

## 对象的内存布局

1. **对象头**：包括 `Mark Word` 和 `Klass Pointer`，存储对象的元数据信息，如哈希码、锁信息、GC 状态等。
2. **实例数据**：存储对象

的实际字段数据，包含基本数据类型和对象引用。
3. **对齐填充**：为了满足内存对齐要求，JVM 可能会在对象中插入填充字节。

[回到目录](#目录)

## 如何判断对象仍然存活

Java 中判断对象是否存活的主要方法是**可达性分析算法**，该算法通过从 GC Roots 出发，遍历对象引用链，来判断对象是否存活。对象的引用类型分为强引用、软引用、弱引用和虚引用，垃圾回收器会根据不同的引用类型采取不同的回收策略。即使对象被标记为不可达，也并不会立即被回收，而是要经过 `finalize()` 方法的自救过程后，才能确定对象是否真的可以被回收。

[回到目录](#目录)

## 垃圾收集算法

垃圾回收算法是 JVM 内存管理中的核心机制，不同的算法适用于不同的内存分配和回收场景。常见的算法有：
- **标记-清除算法**：简单直接，但可能产生内存碎片。
- **复制算法**：高效分配内存，适合年轻代回收，但内存利用率较低。
- **标记-整理算法**：适合老年代回收，解决了内存碎片问题，但移动对象的开销较大。
- **分代收集算法**：根据对象的生命周期特点进行垃圾回收，结合多种算法优化性能。

通过理解这些算法的原理和适用场景，可以更好地优化 Java 应用的性能，减少内存开销和垃圾回收对程序运行的影响。

[回到目录](#目录)

## 详细说一下 CMS 收集器的垃圾收集过程


CMS 收集器是一种**低延迟**的垃圾收集器，主要用于老年代的垃圾回收。其通过标记-清除算法实现垃圾回收，并采用了并发回收机制，大大减少了应用程序的停顿时间。CMS 的工作流程包括**初始标记**、**并发标记**、**重新标记**和**并发清除**，其中并发阶段与应用程序同时执行，有效降低了 GC 对应用的影响。

尽管 CMS 在降低 GC 停顿时间方面表现优异，但其缺点也比较明显，如**内存碎片**、**并发模式失败**以及较高的 CPU 使用率。随着 G1 收集器的出现，CMS 在一些新系统中逐渐被 G1 所取代。然而，CMS 仍然在许多对延迟敏感的应用中使用，尤其是在内存较大的服务端应用中。

![](/src/CMS收集器垃圾收集过程.png)

[回到目录](#目录)

## G1 垃圾收集器

**G1 GC** 是一种**低延迟、可预测**的垃圾收集器，适合大内存、多核 CPU 环境下的 Java 应用程序。它通过将堆划分为多个小区域，采用并行和并发的方式进行垃圾回收，并能够自动整理内存，避免了内存碎片问题。通过 `MaxGCPauseMillis` 参数，用户可以控制垃圾回收的最大停顿时间，帮助应用程序实现更好的响应性能。

尽管 G1 GC 相比于 CMS 提供了更好的内存管理和延迟控制，但它也引入了一定的复杂性。在特定场景下，G1 GC 的性能表现可能需要根据实际需求进行调优。

![](/src/G1垃圾收集器.png)

[回到目录](#目录)

## 对象一定分配在堆中吗

在 Java 中，**对象不一定总是分配在堆中**，尽管大多数情况下，Java 对象确实是分配在堆上。然而，在某些情况下，JVM 可以通过优化技术将对象分配在栈上，或者通过其他机制进行内存管理。这些优化主要依赖于**逃逸分析**等机制。

### 1. **常规情况下，Java 对象分配在堆中**
### 2. **对象可以通过逃逸分析分配在栈上**
### 3. **标量替换优化**


虽然 Java 中大多数对象是分配在堆上的，但并不是所有对象都必须分配在堆中。借助**逃逸分析**和**标量替换**等优化技术，JVM 可以在某些情况下将对象分配在栈上，或者通过分解对象字段来避免分配。栈上的对象在方法执行完毕后会自动回收，而堆上的对象则由垃圾回收器管理。因此，现代 JVM 会根据对象的使用情况，选择最优的内存分配策略以提高性能。

[回到目录](#目录)

## 有哪些常见集合

- **`List`**：`ArrayList`、`LinkedList`、`Vector` 是常见的 `List` 实现类，提供有序、可重复的集合。
- **`Set`**：`HashSet`、`LinkedHashSet`、`TreeSet` 是常见的 `Set` 实现类，保证集合中元素唯一性。
- **`Map`**：`HashMap`、`LinkedHashMap`、`TreeMap` 提供了键值对映射关系，允许快速查找键对应的值。
- **`Queue`**：`PriorityQueue`、`ArrayDeque` 提供了队列和双端队列功能。

Java 的集合框架非常灵活，适用于不同场景的应用程序，开发者可以根据需求选择合适的集合类来提高开发效率和性能。

![](/src/常见集合.png)
![](/src/常见集合map.png)


[回到目录](#目录)

## ArrayList和LinkedList有什么区别

- **ArrayList** 更适合需要频繁随机访问元素，且插入、删除操作不频繁的场景。其优点在于随机访问性能较好、内存利用率较高。
- **LinkedList** 则适合频繁进行插入、删除操作，尤其是在中间插入或删除元素的场景，但它的随机访问性能较差，内存开销也较大。


| 特性                  | **ArrayList**                          | **LinkedList**                        |
|-----------------------|----------------------------------------|---------------------------------------|
| **底层结构**           | 动态数组                               | 双向链表                              |
| **随机访问性能**       | O(1)，快速                             | O(n)，较慢                            |
| **插入删除性能**       | 尾部 O(1)，中间 O(n)                   | 插入/删除 O(1)，但查找位置 O(n)       |
| **内存开销**           | 较小，数组连续                         | 较大，每个元素有额外的节点引用开销     |
| **扩容机制**           | 容量满时扩容 1.5 倍                    | 不需要扩容                            |
| **遍历性能**           | 快速，缓存友好                         | 较慢，内存不连续                      |
| **线程安全**           | 非线程安全（可以使用同步包装器）        | 非线程安全（可以使用同步包装器）       |
[回到目录](#目录)

## ArrayList的扩容机制

- **默认初始容量**：`ArrayList` 的默认初始容量为 **10**，可以通过构造方法指定初始容量。
- **扩容机制**：当 `ArrayList` 中的元素数量超过当前容量时，会触发扩容操作，扩容后的新容量为原容量的 **1.5 倍**。
- **性能影响**：扩容操作涉及创建新数组并复制旧元素，较大容量的 `ArrayList` 在扩容时性能开销会显著增加。因此，建议预估容量并在构造时指定，减少扩容次数。
- **最大容量**：在 64 位 JVM 中，`ArrayList` 的最大容量为 **`Integer.MAX_VALUE - 8`**，超过该容量会抛出 `OutOfMemoryError`。

[回到目录](#目录)

## ArrayList中为什么用transient修饰数组

`ArrayList` 使用 `transient` 修饰 `elementData` 数组的原因主要有以下几点：
- **避免序列化多余的空间**：`ArrayList` 的底层数组可能包含多余的容量，使用 `transient` 可以防止这些未使用的部分被序列化。
- **自定义序列化逻辑**：通过 `writeObject()` 和 `readObject()` 方法，`ArrayList` 仅序列化实际存储的元素，而不是整个数组。
- **提升序列化效率**：减少序列化的数据量和反序列化的开销，避免了无效数据的处理。

[回到目录](#目录)

## 什么是快速失败(fail-fast)和安全失败(fail-safe)

- **快速失败**（fail-fast）集合在检测到结构性修改时会立即抛出 `ConcurrentModificationException`，这是为避免并发修改带来不一致性和数据错误的保护机制。
- **安全失败**（fail-safe）集合通过在迭代时使用集合的副本来实现对并发修改的容忍，即使在遍历时集合发生变化，迭代器也不会受到影响。

在多线程编程中，**安全失败**机制通常用于并发集合（如 `ConcurrentHashMap`），而在单线程或轻量并发修改场景中，**快速失败**机制更为常见（如 `ArrayList` 和 `HashMap` 等非并发集合）。

[回到目录](#目录)

## 怎么保证 ArrayList线程安全

在多线程环境下使用 `ArrayList` 时，可以通过以下几种方式确保线程安全：

1. **使用 `Collections.synchronizedList()`**：通过同步包装器保证线程安全，但在迭代时需要手动同步。
2. **使用 `CopyOnWriteArrayList`**：适合读多写少的场景，在写操作时创建副本，读操作无锁，性能较好。
3. **手动同步 `ArrayList` 操作**：通过 `synchronized` 块手动控制访问，灵活但容易出错。
4. **使用并发工具类**：如 `BlockingQueue` 或 `ConcurrentHashMap`，这些集合类为并发设计，内置了线程安全机制。
5. **使用锁机制**：通过 `ReentrantLock` 显式控制并发访问，提供了更灵活的锁控制。

[回到目录](#目录)

## CopyOnWriteArrayList 了解多少

### **`CopyOnWriteArrayList` 的核心原理**

- **写时复制（Copy-On-Write）**：每当有写操作（如 `add()`、`set()` 或 `remove()`）发生时，`CopyOnWriteArrayList` 会创建一个**当前数组的新副本**，在这个副本上进行修改。修改完成后，将这个新副本替换为原来的数组。
- **读操作不需要加锁**：由于写操作是在副本上进行，读操作总是可以在没有锁的情况下安全进行，因为读操作总是访问一个不可变的快照（原来的数组）。
- **线程安全**：`CopyOnWriteArrayList` 内部通过这种写时复制的方式来保证所有读写操作之间的线程安全，不需要加锁或同步块。

`CopyOnWriteArrayList` 是一种适合**读多写少**场景的线程安全集合。它通过写时复制机制，保证了并发读写操作的安全性和一致性，读操作性能优异，但写操作的开销较大。常用于缓存、监听器等需要高并发读操作的场景。

**使用建议**：
- 如果你的应用程序有频繁的写操作，应该避免使用 `CopyOnWriteArrayList`，可以考虑其他并发集合，如 `ConcurrentHashMap` 或 `Collections.synchronizedList()`。
- 如果你的场景是以读操作为主，写操作非常少，`CopyOnWriteArrayList` 是一个不错的选择，它可以在不加锁的情况下保证高效的读操作。

[回到目录](#目录)

## HashMap的数据结构

数据结构**：`HashMap` 是基于**数组 + 链表 + 红黑树**的结构。每个桶存储一个链表或红黑树来解决哈希冲突。
- **性能优化**：通过链表、红黑树、哈希函数优化等机制，`HashMap` 实现了高效的查找、插入和删除操作。在链表长度超过一定阈值时，`HashMap` 会将链表转换为红黑树，以提升性能。
- **扩容机制**：`HashMap` 使用了负载因子来控制何时进行扩容，默认负载因子为 0.75，扩容会使容量翻倍并重新哈希所有元素。
- **线程安全**：`HashMap` 不是线程安全的，在多线程环境下应使用 `ConcurrentHashMap` 或其他同步机制。

通过这些机制，`HashMap` 在多数情况下能够实现接近 **O(1)** 的查找、插入和删除操作，是一种非常高效的键值对存储结构。

[回到目录](#目录)

## 对红黑树的理解

**红黑树**（Red-Black Tree）是一种**自平衡二叉搜索树**，它通过在每个节点上增加额外的颜色信息（红或黑），来保证树的平衡性，从而保证在最坏情况下查找、插入和删除的时间复杂度为 **O(log n)**。红黑树广泛应用于 Java 的 `TreeMap`、`TreeSet`，以及各种内核调度算法中，成为平衡树实现中的一种经典选择。

[回到目录](#目录)

## 红黑树怎么保持平衡的

可视化工具 <https://www.rmboot.com/RedBlack.html>

红黑树通过保持每个路径上的黑色节点数量相同以及限制红色节点的连续性来确保树的平衡性。插入和删除操作后，红黑树会通过**重新着色**和**旋转操作**来修复可能破坏的平衡性。红黑树能够在最坏情况下提供 **O(log n)** 的查找、插入和删除时间复杂度，是一种非常高效且常用的自平衡二叉搜索树。


[回到目录](#目录)

## 



[回到目录](#目录)

## **A and B**

## 



[回到目录](#目录)