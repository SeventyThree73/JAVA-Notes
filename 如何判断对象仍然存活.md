在 JVM 中，垃圾回收器（Garbage Collector, GC）会定期判断哪些对象仍然存活，哪些对象可以被回收。为了判断对象是否仍然存活，JVM 主要采用两种常见的算法：**引用计数法**和**可达性分析算法**。其中，**可达性分析算法**是 Java 垃圾回收器的主流方法，而引用计数法在 Java 中不常用。

### 1. **可达性分析算法（Reachability Analysis）**

**可达性分析算法**是 JVM 中判断对象是否存活的主要方法。在这个算法中，JVM 会通过一系列称为 "GC Roots" 的对象作为起点，开始进行搜索。如果一个对象可以通过引用链从 GC Roots 到达，那么该对象被认为是存活的；否则，该对象被认为是不可达的，可以被回收。

#### 1.1 **GC Roots**
GC Roots 是一些特殊的对象，它们在任何情况下都不会被垃圾回收，它们作为垃圾回收算法的根对象。如果一个对象可以从 GC Roots 直接或间接访问到，则它被认为是存活的。

常见的 GC Roots 对象包括：
- **栈中的局部变量**：包括当前线程栈中的对象引用。
- **类的静态变量**：存放在方法区的静态字段所引用的对象。
- **常量池中的引用**：如字符串常量池中的引用。
- **本地方法栈中的 JNI 引用**：通过 JNI 调用的本地代码中的对象引用。

#### 1.2 **可达性分析的过程**
在可达性分析中，JVM 从 GC Roots 开始，遍历所有引用到的对象。如果某个对象可以通过一条或多条引用链与 GC Roots 相连，则该对象是存活的；如果没有引用链与 GC Roots 相连，则该对象将被标记为不可达。

**示例**：

假设有如下对象关系：
```
GC Root → A → B → C
            ↓
            D → E
```
- 从 GC Roots 出发，`A`、`B`、`C`、`D`、`E` 都可以通过引用链访问到，所以它们都是存活的。
- 如果对象 `E` 没有被 `D` 引用，那么 `E` 将被标记为不可达，随后可以被垃圾回收。

### 2. **对象的四种引用类型**

在 Java 中，引用分为**四种级别**，垃圾回收器根据不同的引用类型判断对象是否存活。不同引用类型的对象在可达性分析中处理方式不同。

#### 2.1 **强引用（Strong Reference）**
- **定义**：这是最常见的引用类型，通常使用类似 `Object obj = new Object();` 的方式创建的引用都是强引用。
- **特点**：只要一个对象存在强引用，垃圾回收器就不会回收该对象，强引用是不可回收的，除非手动将引用置为 `null`。

#### 2.2 **软引用（Soft Reference）**
- **定义**：软引用用于描述一些在内存不足时可以被回收的对象。它通常用于实现内存敏感的缓存。
- **特点**：当 JVM 内存不足时，垃圾回收器会回收软引用指向的对象。若内存充足，则软引用对象可以继续保留。

```java
SoftReference<MyObject> softRef = new SoftReference<>(new MyObject());
```

#### 2.3 **弱引用（Weak Reference）**
- **定义**：弱引用是一种比软引用更弱的引用类型。它在下一次垃圾回收时无论内存是否充足，都会被回收。
- **特点**：当垃圾回收器发现一个对象只被弱引用引用时，不管当前内存是否充足，都会回收该对象。

```java
WeakReference<MyObject> weakRef = new WeakReference<>(new MyObject());
```

#### 2.4 **虚引用（Phantom Reference）**
- **定义**：虚引用是最弱的引用类型，主要用于跟踪对象被垃圾回收的活动。通过 `PhantomReference` 和引用队列，开发者可以得知对象被回收的时机。
- **特点**：虚引用本身不会阻止对象被回收，并且对象一旦有了虚引用，在任何时候都可能被回收。它的唯一作用是在对象被回收之前收到通知。

```java
PhantomReference<MyObject> phantomRef = new PhantomReference<>(new MyObject(), refQueue);
```

### 3. **对象的死亡过程**

当对象被垃圾回收器判断为不可达时，并不会立即被回收，通常会经过以下过程：

#### 3.1 **第一次标记**
- 对象在可达性分析中如果没有与 GC Roots 相连，则会被第一次标记为 "不可达"。
- 如果对象覆盖了 `finalize()` 方法，则对象会被放置在一个名为 `F-Queue` 的队列中，稍后由 JVM 调用对象的 `finalize()` 方法。
  
#### 3.2 **是否重生**
- `finalize()` 方法会给对象一次自救的机会。如果对象在 `finalize()` 方法中重新与 GC Roots 建立关联（即将自己重新引用），对象会被移出 "不可达" 集合，成为存活状态。
- 如果对象没有在 `finalize()` 中成功自救，它将被第二次标记为不可达。

#### 3.3 **第二次标记**
- 在 `finalize()` 之后，如果对象仍然没有与 GC Roots 产生任何引用链，则对象将被判定为不可回收。此时对象彻底进入 "死亡" 状态，可以被垃圾回收器回收。

**注意**：`finalize()` 方法在 Java 中不推荐使用，因为它的执行时间不确定且效率低下，JVM 并不保证 `finalize()` 一定会执行。

### 4. **判断对象存活的其他机制**

#### 4.1 **逃逸分析（Escape Analysis）**
- 逃逸分析是 JVM 的一种优化技术，用来判断对象是否会逃逸出方法作用范围。
- 如果一个对象在方法中创建并且没有逃逸到方法外部，则 JVM 可以将该对象分配在栈上，而不是堆上。
- 对象分配在栈上时，在方法执行结束后，栈帧被弹出，内存会自动释放，而无需垃圾回收。

```java
public void example() {
    Object obj = new Object();  // 没有逃逸出方法
}
```

#### 4.2 **引用队列（Reference Queue）**
- 对于软引用、弱引用和虚引用，当垃圾回收器回收这些对象时，可以通过引用队列（`ReferenceQueue`）通知开发者对象已被回收。
- 使用引用队列可以监控对象的生命周期，尤其是在虚引用中，开发者可以感知对象的回收时机。

### 5. **对象存活的特殊情况**

#### 5.1 **栈上的对象**
在某些情况下，通过逃逸分析优化，JVM 可以将对象分配在栈上，而不是堆上。栈上的对象会在方法执行结束后随栈帧销毁，而不依赖于垃圾回收机制。

#### 5.2 **永久代/元空间对象**
在 Java 8 之前，类的元数据存储在永久代中，永久代中的对象不会被频繁回收（但类卸载时会被清理）。从 Java 8 开始，JVM 使用元空间（Metaspace）替代永久代，元空间用于存储类的元数据。

### 总结

Java 中判断对象是否存活的主要方法是**可达性分析算法**，该算法通过从 GC Roots 出发，遍历对象引用链，来判断对象是否存活。对象的引用类型分为强引用、软引用、弱引用和虚引用，垃圾回收器会根据不同的引用类型采取不同的回收策略。即使对象被标记为不可达，也并不会立即被回收，而是要经过 `finalize()` 方法的自救过程后，才能确定对象是否真的可以被回收。